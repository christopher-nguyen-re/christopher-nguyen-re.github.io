"use strict";(self.webpackChunkchristopher_nguyen_re=self.webpackChunkchristopher_nguyen_re||[]).push([[1590],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),s=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=s(e.components);return a.createElement(c.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=s(n),u=r,b=d["".concat(c,".").concat(u)]||d[u]||m[u]||l;return n?a.createElement(b,o(o({ref:t},p),{},{components:n})):a.createElement(b,o({ref:t},p))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var s=2;s<l;s++)o[s]=n[s];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2419:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>m,frontMatter:()=>l,metadata:()=>i,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const l={slug:"baby-c",title:"baby-c",authors:["nguyen"],tags:["CTF","Binary Exploitation","decompetition"]},o=void 0,i={permalink:"/blog/baby-c",editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-02-15-baby-c.md",source:"@site/blog/2022-02-15-baby-c.md",title:"baby-c",description:"Decompetition.io: baby-c",date:"2022-02-15T00:00:00.000Z",formattedDate:"February 15, 2022",tags:[{label:"CTF",permalink:"/blog/tags/ctf"},{label:"Binary Exploitation",permalink:"/blog/tags/binary-exploitation"},{label:"decompetition",permalink:"/blog/tags/decompetition"}],readingTime:4.76,truncated:!0,authors:[{name:"Christopher Nguyen",title:"Reverse Engineer",url:"https://github.com/christopher-nguyen-re",imageURL:"https://cdn.cnn.com/cnnnext/dam/assets/190517103414-01-grumpy-cat-file-restricted.jpg",key:"nguyen"}],frontMatter:{slug:"baby-c",title:"baby-c",authors:["nguyen"],tags:["CTF","Binary Exploitation","decompetition"]},prevItem:{title:"Are you root?",permalink:"/blog/are-you-root"},nextItem:{title:"Stonks",permalink:"/blog/stonks"}},c={authorsImageUrls:[void 0]},s=[{value:"The Challenge",id:"the-challenge",level:2},{value:"Analysis",id:"analysis",level:2},{value:"Full assembly",id:"full-assembly",level:3},{value:"Examining assembly components",id:"examining-assembly-components",level:3},{value:"Running the executable",id:"running-the-executable",level:3},{value:"Solving the challenge",id:"solving-the-challenge",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:s};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Decompetition.io: baby-c"),(0,r.kt)("h2",{id:"the-challenge"},"The Challenge"),(0,r.kt)("p",null,"This challenge can be found ",(0,r.kt)("a",{parentName:"p",href:"https://decompetition.io/challenges"},"here"),"."),(0,r.kt)("p",null,"The provided executable ",(0,r.kt)("a",{parentName:"p",href:"/files/baby-c/baby-c"},"here")),(0,r.kt)("p",null,"The goal of this challenge is to recreate the baby-c source file so that when it is decompiled, the assembly matches the provided target."),(0,r.kt)("h2",{id:"analysis"},"Analysis"),(0,r.kt)("p",null,"First, I looked at the provided assembly and attempted to figure out the program's general behavior. The challenge tells us that Intel syntax is used."),(0,r.kt)("h3",{id:"full-assembly"},"Full assembly"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"main:\n  endbr64\n  push    rbp\n  mov     rbp, rsp\n  push    rbx\n  sub     rsp, 0x18\n  mov     [rbp-0x15], 1\nblock1:\n  mov     rax, [stdin]\n  mov     rdi, rax\n  call    getc@plt.sec\n  mov     [rbp-0x14], eax\n  cmp     [rbp-0x14], -1\n  je      block7\nblock2:\n  call    __ctype_b_loc@plt.sec\n  mov     rax, [rax]\n  mov     edx, [rbp-0x14]\n  movsxd  rdx, edx\n  add     rdx, rdx\n  add     rax, rdx\n  movzx   eax, [rax]\n  movzx   eax, ax\n  and     eax, 0x2000\n  test    eax, eax\n  je      block4\nblock3:\n  mov     rdx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     rsi, rdx\n  mov     edi, eax\n  call    putc@plt.sec\n  mov     [rbp-0x15], 1\n  jmp     block1\nblock4:\n  cmp     [rbp-0x15], 0\n  je      block6\nblock5:\n  mov     rbx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     edi, eax\n  call    toupper@plt.sec\n  mov     rsi, rbx\n  mov     edi, eax\n  call    putc@plt.sec\n  mov     [rbp-0x15], 0\n  jmp     block1\nblock6:\n  mov     rbx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     edi, eax\n  call    tolower@plt.sec\n  mov     rsi, rbx\n  mov     edi, eax\n  call    putc@plt.sec\n  jmp     block1\nblock7:\n  mov     eax, 0\n  add     rsp, 0x18\n  pop     rbx\n  pop     rbp\n  ret\n")),(0,r.kt)("h3",{id:"examining-assembly-components"},"Examining assembly components"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"main:\n  endbr64\n  push    rbp\n  mov     rbp, rsp\n  push    rbx\n  sub     rsp, 0x18\n  mov     [rbp-0x15], 1\n")),(0,r.kt)("p",null,"From main, the stack was allocated and the value '1' is stored on the stack at ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x15]"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block1:\n  mov     rax, [stdin]\n  mov     rdi, rax\n  call    getc@plt.sec\n  mov     [rbp-0x14], eax\n  cmp     [rbp-0x14], -1\n  je      block7\n")),(0,r.kt)("p",null,"In block 1, getc is called with stdin as its argument. The return value of getc is moved from eax into ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x14]"),", a location on the stack. It checks the return value for the value '-1' and jumps to block 7 if it is equal. If it is not equal, the assembly control flow continues into block 2."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block2:\n  call    __ctype_b_loc@plt.sec\n  mov     rax, [rax]\n  mov     edx, [rbp-0x14]\n  movsxd  rdx, edx\n  add     rdx, rdx\n  add     rax, rdx\n  movzx   eax, [rax]\n  movzx   eax, ax\n  and     eax, 0x2000\n  test    eax, eax\n  je      block4\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"__ctype_b_loc")," is an accessor function used by the ctype library. It returns an ",(0,r.kt)("inlineCode",{parentName:"p"},"unsigned short int**")," which points to array of characters in the current locale containing characteristics for each current character set. The character that had been received from ",(0,r.kt)("inlineCode",{parentName:"p"},"getc")," is used and its characteristic was checked to match ",(0,r.kt)("inlineCode",{parentName:"p"},"0x2000"),". ",(0,r.kt)("inlineCode",{parentName:"p"},"0x2000")," was the value for the ",(0,r.kt)("inlineCode",{parentName:"p"},"_ISspace")," constant contained in ctype.h. From this I determined that the ",(0,r.kt)("inlineCode",{parentName:"p"},"isspace()")," function was likely used to check that the character was a space. If this was true, the assembly would jump to block4. Otherwise, it continued to block 3."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block3:\n  mov     rdx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     rsi, rdx\n  mov     edi, eax\n  call    putc@plt.sec\n  mov     [rbp-0x15], 1\n  jmp     block1\n")),(0,r.kt)("p",null,"This block simply called ",(0,r.kt)("inlineCode",{parentName:"p"},"putc")," with the character we obtained from ",(0,r.kt)("inlineCode",{parentName:"p"},"getc")," stored at ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x14]"),". It stored the value '1' into ","[rbp-0x15]"," and jumped back to block1. This implied that there was a loop in the main function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block4:\n  cmp     [rbp-0x15], 0\n  je      block6\n")),(0,r.kt)("p",null,"Block4 checked that the value stored at ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x15]")," was 0 and jumped to block 6 if true. Otherwise, it continued to block 5. ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x15]")," gave me the impression that it was being used as a flag for something."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block5:\n  mov     rbx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     edi, eax\n  call    toupper@plt.sec\n  mov     rsi, rbx\n  mov     edi, eax\n  call    putc@plt.sec\n  mov     [rbp-0x15], 0\n  jmp     block1\n")),(0,r.kt)("p",null,"Here, ",(0,r.kt)("inlineCode",{parentName:"p"},"toupper()")," was called with ",(0,r.kt)("inlineCode",{parentName:"p"},"stdout")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x14"),"] as arguments. By this point we already knew that ",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x14]")," is the character we obtain from ",(0,r.kt)("inlineCode",{parentName:"p"},"getc")," stored on the stack. ",(0,r.kt)("inlineCode",{parentName:"p"},"putc")," is then called to print the character. If ",(0,r.kt)("inlineCode",{parentName:"p"},"toupper")," was successful, then this character would be capitalized. Otherwise, the character would be unchanged and printed to ",(0,r.kt)("inlineCode",{parentName:"p"},"stdout"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block6:\n  mov     rbx, [stdout]\n  mov     eax, [rbp-0x14]\n  mov     edi, eax\n  call    tolower@plt.sec\n  mov     rsi, rbx\n  mov     edi, eax\n  call    putc@plt.sec\n  jmp     block1\n")),(0,r.kt)("p",null,"This was the same as block5. The only difference was that it called ",(0,r.kt)("inlineCode",{parentName:"p"},"tolower()")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"toupper()"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-assembly"},"block7:\n  mov     eax, 0\n  add     rsp, 0x18\n  pop     rbx\n  pop     rbp\n  ret\n")),(0,r.kt)("p",null,"Block 7 was the point where the main function deallocated stack memory and returned. I expected this to be the end of the main function."),(0,r.kt)("h3",{id:"running-the-executable"},"Running the executable"),(0,r.kt)("p",null,"I ran the executable and observed its behavior to compare my understanding of the assembly."),(0,r.kt)("p",null,"The first character of every ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," was capitalized if it was a letter. All uppercase letters after the first for each ",(0,r.kt)("inlineCode",{parentName:"p"},"word")," were changed to lowercase. Words were separated by spaces."),(0,r.kt)("p",null,"This lined up with the assembly as a flag (",(0,r.kt)("inlineCode",{parentName:"p"},"[rbp-0x15]"),") handles the control flow for whether a character should be capitalized or made lowercase."),(0,r.kt)("h2",{id:"solving-the-challenge"},"Solving the challenge"),(0,r.kt)("p",null,"I wrote up a program in c to match the executable's behavior along with what I knew from the assembly. I had to modify ",(0,r.kt)("inlineCode",{parentName:"p"},"if")," statements a few times for the control flow to match in assembly."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-c"},"#include <ctype.h>\n#include <stdio.h>\n\nint main() {\n  // glhf\n  char flag;\n  int letter;\n  \n  flag = 1;\n  while (1)\n  {\n    letter = getc(stdin);\n  \n    if (letter == -1)\n    {\n      break;\n    }\n\n    if (isspace(letter) != 0)\n    {\n     putc(letter, stdout);\n     flag = 1;\n    }\n    else\n    {\n      if (flag != 0)\n      {\n        putc(toupper(letter), stdout);\n        flag = 0;\n      }\n      else\n      {\n        putc(tolower(letter), stdout);\n      }\n    }\n  }\n\n  return 0;\n}\n")),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"This was an interesting challenge and helped me gain a better understanding of the relationship between c and assembly. I learned about calling conventions and how to read the control flow of assembly."))}m.isMDXComponent=!0}}]);